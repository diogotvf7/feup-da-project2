<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TSP: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TSP
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_graph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Graph Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a53c05c92be95433b8f92ab5f7c0c2c76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a53c05c92be95433b8f92ab5f7c0c2c76">findNode</a> (const int &amp;idNode) const</td></tr>
<tr class="memdesc:a53c05c92be95433b8f92ab5f7c0c2c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for finding a node in the graph.  <a href="class_graph.html#a53c05c92be95433b8f92ab5f7c0c2c76">More...</a><br /></td></tr>
<tr class="separator:a53c05c92be95433b8f92ab5f7c0c2c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64223993d53457e543061d81597cc5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ac64223993d53457e543061d81597cc5a">addNode</a> (<a class="el" href="class_node.html">Node</a> *node)</td></tr>
<tr class="memdesc:ac64223993d53457e543061d81597cc5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for adding a node to the graph.  <a href="class_graph.html#ac64223993d53457e543061d81597cc5a">More...</a><br /></td></tr>
<tr class="separator:ac64223993d53457e543061d81597cc5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95128181b660eea25cb9b441517f2e2"><td class="memItemLeft" align="right" valign="top">node_map&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ac95128181b660eea25cb9b441517f2e2">getNodes</a> () const</td></tr>
<tr class="memdesc:ac95128181b660eea25cb9b441517f2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get function for the graph's nodes.  <a href="class_graph.html#ac95128181b660eea25cb9b441517f2e2">More...</a><br /></td></tr>
<tr class="separator:ac95128181b660eea25cb9b441517f2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0771561a02acaf9387906aefae7ed5a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a0771561a02acaf9387906aefae7ed5a6">createEdge</a> (const int &amp;src, const int &amp;dest, double dist) const</td></tr>
<tr class="memdesc:a0771561a02acaf9387906aefae7ed5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for adding a bidirectional edge to the graph.  <a href="class_graph.html#a0771561a02acaf9387906aefae7ed5a6">More...</a><br /></td></tr>
<tr class="separator:a0771561a02acaf9387906aefae7ed5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f520eaf352894043bee76b3b3de123e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a4f520eaf352894043bee76b3b3de123e">distanceBetween</a> (int src, int dest, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;cache)</td></tr>
<tr class="memdesc:a4f520eaf352894043bee76b3b3de123e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that checks the distance between two nodes. In order to avoid recalculating the same distance multiple times, it uses a cache to store the distances between nodes. If the distance between the two nodes is not in the cache, it calculates it and stores it in the cache.  <a href="class_graph.html#a4f520eaf352894043bee76b3b3de123e">More...</a><br /></td></tr>
<tr class="separator:a4f520eaf352894043bee76b3b3de123e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a19892f3907684f765f981e9f96730"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aa5a19892f3907684f765f981e9f96730">tspBacktracking</a> ()</td></tr>
<tr class="memdesc:aa5a19892f3907684f765f981e9f96730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Caller function for the backtracking approach for solving the TSP in a graph.  <a href="class_graph.html#aa5a19892f3907684f765f981e9f96730">More...</a><br /></td></tr>
<tr class="separator:aa5a19892f3907684f765f981e9f96730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2e3afb397648a95cfc811cb9949ee3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#abe2e3afb397648a95cfc811cb9949ee3">backtrack</a> (<a class="el" href="class_node.html">Node</a> *currentNode, std::vector&lt; int &gt; &amp;path, double currentDist, <a class="el" href="struct_path.html">Path</a> &amp;bestPath)</td></tr>
<tr class="memdesc:abe2e3afb397648a95cfc811cb9949ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that performs the backtracking approach for solving the TSP in a graph.  <a href="class_graph.html#abe2e3afb397648a95cfc811cb9949ee3">More...</a><br /></td></tr>
<tr class="separator:abe2e3afb397648a95cfc811cb9949ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb18a1f9d2ad51214d4211d60edf6860"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#acb18a1f9d2ad51214d4211d60edf6860">prim</a> ()</td></tr>
<tr class="memdesc:acb18a1f9d2ad51214d4211d60edf6860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that performs the Prim's algorithm for finding the minimum spanning tree of a graph.  <a href="class_graph.html#acb18a1f9d2ad51214d4211d60edf6860">More...</a><br /></td></tr>
<tr class="separator:acb18a1f9d2ad51214d4211d60edf6860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b32e522e9ad06e9a1bfcc890c48ebd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a10b32e522e9ad06e9a1bfcc890c48ebd">preOrderWalk</a> (<a class="el" href="class_node.html">Node</a> *node, std::vector&lt; int &gt; &amp;path)</td></tr>
<tr class="memdesc:a10b32e522e9ad06e9a1bfcc890c48ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that performs the pre-order walk of a tree.  <a href="class_graph.html#a10b32e522e9ad06e9a1bfcc890c48ebd">More...</a><br /></td></tr>
<tr class="separator:a10b32e522e9ad06e9a1bfcc890c48ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0b3116a973ae85a15dce4506940912"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#abf0b3116a973ae85a15dce4506940912">approxTSPTour</a> ()</td></tr>
<tr class="memdesc:abf0b3116a973ae85a15dce4506940912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that performs the triangular approximation algorithm for solving the TSP in a graph.  <a href="class_graph.html#abf0b3116a973ae85a15dce4506940912">More...</a><br /></td></tr>
<tr class="separator:abf0b3116a973ae85a15dce4506940912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0f2c003a6cc3de010e9a66a7fa2221"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a0f0f2c003a6cc3de010e9a66a7fa2221">aco</a> (std::vector&lt; std::vector&lt; double &gt;&gt; &amp;pheromoneTrails, double evaporationRate, double pheromoneDeposit, int numIterations, int numAnts, int ALPHA, int BETA, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;distanceCache)</td></tr>
<tr class="memdesc:a0f0f2c003a6cc3de010e9a66a7fa2221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that performs the ant colony optimization algorithm for solving the TSP in a graph.  <a href="class_graph.html#a0f0f2c003a6cc3de010e9a66a7fa2221">More...</a><br /></td></tr>
<tr class="separator:a0f0f2c003a6cc3de010e9a66a7fa2221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c9a1772e6f35de83ffc262d939ed2d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#af5c9a1772e6f35de83ffc262d939ed2d">apply2OptSwap</a> (<a class="el" href="struct_path.html">Path</a> &amp;antPath, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;distanceCache, int maxIterations=INT32_MAX)</td></tr>
<tr class="memdesc:af5c9a1772e6f35de83ffc262d939ed2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that performs the 2 optimization swap algorithm for improving a path presented as a TSP solution.  <a href="class_graph.html#af5c9a1772e6f35de83ffc262d939ed2d">More...</a><br /></td></tr>
<tr class="separator:af5c9a1772e6f35de83ffc262d939ed2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a26c3f151f72360afe15a989ee1366a46"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a26c3f151f72360afe15a989ee1366a46">updatePheromoneTrails</a> (std::vector&lt; std::vector&lt; double &gt;&gt; &amp;pheromoneTrails, const std::vector&lt; <a class="el" href="struct_path.html">Path</a> &gt; &amp;ants, double evaporationRate, double pheromoneDeposit)</td></tr>
<tr class="memdesc:a26c3f151f72360afe15a989ee1366a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that updates the pheromone trails of the graph.  <a href="class_graph.html#a26c3f151f72360afe15a989ee1366a46">More...</a><br /></td></tr>
<tr class="separator:a26c3f151f72360afe15a989ee1366a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0f0f2c003a6cc3de010e9a66a7fa2221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0f2c003a6cc3de010e9a66a7fa2221">&#9670;&nbsp;</a></span>aco()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_path.html">Path</a> Graph::aco </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>pheromoneTrails</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>evaporationRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pheromoneDeposit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numIterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numAnts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>distanceCache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that performs the ant colony optimization algorithm for solving the TSP in a graph. </p>
<dl class="section user"><dt>Complexity:</dt><dd>Complexity: O(I * A * (N^2 + (E^2 + A * N))) where I is the number of iterations, A is the number of ants, N is the number of nodes and E is the number of edges of the graph. This complexity is due to the fact for every iteration, each ant has to build a path (this action may, in the worst case, iterate through every node twice, hence the N²) and also has to update the pheromone trails (this action has a complexity of E² + A * N). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pheromoneTrails</td><td>the pheromone trails of the graph </td></tr>
    <tr><td class="paramname">evaporationRate</td><td>the evaporation rate of the pheromones </td></tr>
    <tr><td class="paramname">pheromoneDeposit</td><td>the amount of pheromones that are deposited in the pheromone trails </td></tr>
    <tr><td class="paramname">numIterations</td><td>the number of iterations of the algorithm </td></tr>
    <tr><td class="paramname">numAnts</td><td>the number of ants that are going to be used in the algorithm </td></tr>
    <tr><td class="paramname">ALPHA</td><td>the alpha parameter of the algorithm </td></tr>
    <tr><td class="paramname">BETA</td><td>the beta parameter of the algorithm </td></tr>
    <tr><td class="paramname">distanceCache</td><td>the cache that stores the distances between nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the path with the minimum distance </dd></dl>

</div>
</div>
<a id="ac64223993d53457e543061d81597cc5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64223993d53457e543061d81597cc5a">&#9670;&nbsp;</a></span>addNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for adding a node to the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node we want to add to the graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5c9a1772e6f35de83ffc262d939ed2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c9a1772e6f35de83ffc262d939ed2d">&#9670;&nbsp;</a></span>apply2OptSwap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::apply2OptSwap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>antPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>distanceCache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxIterations</em> = <code>INT32_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that performs the 2 optimization swap algorithm for improving a path presented as a TSP solution. </p>
<dl class="section user"><dt>Complexity:</dt><dd>Complexity: O(I * N²) where I is the number of iterations and N is the number of nodes. This complexity is due to the fact that for every iteration, the algorithm has to iterate through every node twice (hence the N²). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">antPath</td><td>the path to be improved </td></tr>
    <tr><td class="paramname">distanceCache</td><td>the cache that stores the distances between nodes </td></tr>
    <tr><td class="paramname">maxIterations</td><td>the maximum number of iterations of the algorithm, -1 if there is no limit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the fraction of the improvement </dd></dl>

</div>
</div>
<a id="abf0b3116a973ae85a15dce4506940912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf0b3116a973ae85a15dce4506940912">&#9670;&nbsp;</a></span>approxTSPTour()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_path.html">Path</a> Graph::approxTSPTour </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that performs the triangular approximation algorithm for solving the TSP in a graph. </p>
<dl class="section user"><dt>Complexity:</dt><dd>Complexity: O((V + E) log V) + O(V + E) + O(V) which is equivalent to O((V + E) log V) where V is the number of vertices and E is the number of edges. This complexity is due to the fact that this algorithm uses Prim's algorithm to find the minimum spanning tree and then it uses the pre-order walk to find the path. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>returns the path with the minimum distance </dd></dl>

</div>
</div>
<a id="abe2e3afb397648a95cfc811cb9949ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe2e3afb397648a95cfc811cb9949ee3">&#9670;&nbsp;</a></span>backtrack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::backtrack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>currentNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>currentDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>bestPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that performs the backtracking approach for solving the TSP in a graph. </p>
<dl class="section user"><dt>Complexity:</dt><dd>Complexity: O(n!) where n is the number of nodes. This high complexity is due to the fact that this algorithm has to calculate every possible permutation of the nodes in the graph. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentNode</td><td>the current node </td></tr>
    <tr><td class="paramname">path</td><td>the path that is being built </td></tr>
    <tr><td class="paramname">currentDist</td><td>the current distance of the path </td></tr>
    <tr><td class="paramname">bestPath</td><td>the the minimum distance path's information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0771561a02acaf9387906aefae7ed5a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0771561a02acaf9387906aefae7ed5a6">&#9670;&nbsp;</a></span>createEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::createEdge </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for adding a bidirectional edge to the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the id of the source node </td></tr>
    <tr><td class="paramname">dest</td><td>the id of the destination node </td></tr>
    <tr><td class="paramname">dist</td><td>the distance between the two nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f520eaf352894043bee76b3b3de123e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f520eaf352894043bee76b3b3de123e">&#9670;&nbsp;</a></span>distanceBetween()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::distanceBetween </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that checks the distance between two nodes. In order to avoid recalculating the same distance multiple times, it uses a cache to store the distances between nodes. If the distance between the two nodes is not in the cache, it calculates it and stores it in the cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the id of the source node </td></tr>
    <tr><td class="paramname">dest</td><td>the id of the destination node </td></tr>
    <tr><td class="paramname">cache</td><td>the cache that stores the distances between nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the distance between the two nodes </dd></dl>

</div>
</div>
<a id="a53c05c92be95433b8f92ab5f7c0c2c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c05c92be95433b8f92ab5f7c0c2c76">&#9670;&nbsp;</a></span>findNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> * Graph::findNode </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>idNode</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for finding a node in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idNode</td><td>the id of the node we want to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity:</dt><dd>Complexity: O(1) as it uses an unordered_map and all keys are unique </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the node with the given id </dd></dl>

</div>
</div>
<a id="ac95128181b660eea25cb9b441517f2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac95128181b660eea25cb9b441517f2e2">&#9670;&nbsp;</a></span>getNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">node_map Graph::getNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get function for the graph's nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>returns the graph's nodes </dd></dl>

</div>
</div>
<a id="a10b32e522e9ad06e9a1bfcc890c48ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b32e522e9ad06e9a1bfcc890c48ebd">&#9670;&nbsp;</a></span>preOrderWalk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::preOrderWalk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that performs the pre-order walk of a tree. </p>
<dl class="section user"><dt>Complexity:</dt><dd>Complexity: O(V + E) where V is the number of vertices and E is the number of edges. This complexity is due to the fact that this algorithm has to visit every node and, in the worst case, every edge in the tree. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the current node </td></tr>
    <tr><td class="paramname">path</td><td>the path that is being built </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb18a1f9d2ad51214d4211d60edf6860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb18a1f9d2ad51214d4211d60edf6860">&#9670;&nbsp;</a></span>prim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::prim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that performs the Prim's algorithm for finding the minimum spanning tree of a graph. </p>
<dl class="section user"><dt>Complexity:</dt><dd>Complexity: O((V + E) log V) where E is the number of edges and V is the number of vertices. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>returns the minimum spanning tree </dd></dl>

</div>
</div>
<a id="aa5a19892f3907684f765f981e9f96730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a19892f3907684f765f981e9f96730">&#9670;&nbsp;</a></span>tspBacktracking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_path.html">Path</a> Graph::tspBacktracking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Caller function for the backtracking approach for solving the TSP in a graph. </p>
<dl class="section return"><dt>Returns</dt><dd>returns the path with the minimum distance </dd></dl>

</div>
</div>
<a id="a26c3f151f72360afe15a989ee1366a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26c3f151f72360afe15a989ee1366a46">&#9670;&nbsp;</a></span>updatePheromoneTrails()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::updatePheromoneTrails </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>pheromoneTrails</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_path.html">Path</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>evaporationRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pheromoneDeposit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that updates the pheromone trails of the graph. </p>
<dl class="section user"><dt>Complexity:</dt><dd>Complexity: O((E^2) + (A * N)) where A is the number of ants, N is the number of nodes and E is the number of edges of the graph. This complexity is due to the fact that this algorithm has to update the pheromone trails for every ant and that for every edge of the graph the pheromones evaporation must be applied. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pheromoneTrails</td><td>the pheromone trails of the graph </td></tr>
    <tr><td class="paramname">ants</td><td>the ants that are currently in the graph </td></tr>
    <tr><td class="paramname">evaporationRate</td><td>the evaporation rate of the pheromones </td></tr>
    <tr><td class="paramname">pheromoneDeposit</td><td>the amount of pheromones that are deposited in the pheromone trails </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>headers/<a class="el" href="_graph_8h_source.html">Graph.h</a></li>
<li>source/Graph.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
